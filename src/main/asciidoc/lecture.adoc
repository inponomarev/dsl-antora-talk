= Automating Documentation: From DSL to Dynamic Docs with Asciidoctor and Antora
Ivan Ponomarev
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:stem: latexmath


//== Часть 1. Введение
:!figure-caption:

[%notitle]
== Who am I

[cols="30a,70a"]
|===
|image::ivan.jpg[]
|

Ivan Ponomarev

* Team Lead at Synthesized.io (test data automation you can trust!)
* Teaching CS and programming at universities
* Writing technical documentation and slides is a substantial part of my everyday work
|===

== The product we document

* Transforms and generates data in relational databases

* At its core, it includes ~35 transformers/generators, for example:

** Random number generator
** Person generator (gender, age, name, etc.)
** Categorical generator (randomly selects one value from a predefined list)
** …and more

== What we document

* The transformation/generation process can be configured via:
** A YAML file
** A UI (projectional editor)

* The product evolves over time:
** New transformers are added
** Existing transformers change and gain new capabilities

== Things that must stay in sync

[cols="30a,70a"]
|===
|
* **JSONSchema for the YAML configuration**
* The projectional editor UI
* Documentation
|
image::yamlconfig.png[]
|===

== Things that must stay in sync

[cols="30a,70a"]
|===
|
* JSONSchema for the YAML configuration
* **The projectional editor UI**
* Documentation
|
image::projectional.png[]
|===


== Things that must stay in sync

[cols="30a,70a"]
|===
|
* JSONSchema for the YAML configuration
* The projectional editor UI
* **Documentation**
|
image::documentation.png[]

|===

== DSL as a source of truth to the resque

[graphviz, "dsl.png"]
-----

digraph UpsideDownTree {
  rankdir=LR;
  graph [ dpi = 180 ];
  graph [bgcolor="white", pad=0.25, nodesep=0.35, ranksep=0.6];
  node  [shape=box, style="rounded,filled", fillcolor="white", color="#444444",
         fontname="Helvetica", fontsize=12, margin="0.18,0.10"];
  edge  [color="#666666", arrowsize=0.7];

  top [label="DSL\n(OpenAPI components section)"];

  kotlin [label="Kotlin DTOs"];
  ts     [label="TypeScript DTOs"];
  yaml   [label="JsonSchema for YAML config"];
  proj   [label="JsonSchema for Projectional Editor"];

  docs [label="Documentation"];

  top -> kotlin;
  top -> ts;
  top -> yaml;
  top -> proj;
  top -> docs;
}
-----

== Example DSL fragment
Typenames, structure, nullability, descriptions -- all in one place:
[source,yaml]
----
ContinuousGeneratorParams:
  title: Continuous generator
  nullable: false
  allOf:
    - $ref: "#/components/schemas/TransformationParams"
    - type: object
      description: >
        Output data is sampled from a parameterized continuous distribution. [...]
      properties:
        mean:
          description: Mean of the sampled distribution
          type: number
          format: double
          nullable: true
        std:
          description: Standard Deviation
          [...]
        min:
          [...]
        max:
          [...]
        numeric_type:
          $ref: '#/components/schemas/NumericType'
        [...]
----
== Why OpenAPI spec as DSL?

[%step]
* It has built-in documentation fields (`description`, `title`).
* It supports non-standard extension attributes via `x-...` fields. +
For example, we use `x-extends: java.io.Serializable` to make the code generator emit a `Serializable` class.
* There is a high-quality, widely used OpenAPI parser for the JVM: +
https://github.com/swagger-api/swagger-parser

== Why OpenAPI spec as DSL?

* We already had code generators for Kotlin and TypeScript.

* The remaining step was to generate Asciidoctor from the same source, and then rely on the Asciidoctor toolchain for everything that follows.

[graphviz]
----
digraph OpenApiToAdocPipeline {
graph [ dpi = 200 ];
rankdir=LR;
graph [bgcolor="white", pad=0.25, nodesep=0.35, ranksep=0.6];
node  [shape=box, style="rounded,filled", fillcolor="white", color="#444444",
fontname="Helvetica", fontsize=12, margin="0.18,0.10"];
edge  [color="#666666", arrowsize=0.7];

  openapi [style=invis];
  parser  [label="swagger-parser"];
  gen     [label="AdocGenerator\n(the custom-made part)", fillcolor="#FFE66D",  // yellow highlight
        color="#C9A700"];
  adoc    [label="AsciiDoctor\ntoolset"];
  html    [style=invis];

  openapi -> parser [label="OpenAPI spec\ntransformations.yaml"];
  parser  -> gen [label="SwaggerParseResult"];
  gen     -> adoc   [label="transformations.adoc"];
  adoc    -> html [label="HTML+CSS"]
}
----

[.fragment]
It's much easier to generate semantic markup language such as Asciidoctor than trying to generate HTML!

== DSL Pipeline: full picture

[graphviz]
----
digraph OpenApiToAdocPipeline {
graph [ dpi = 200 ];
rankdir=LR;
graph [bgcolor="white", pad=0.25, nodesep=0.35, ranksep=0.6];
node  [shape=box, style="rounded,filled", fillcolor="white", color="#444444",
fontname="Helvetica", fontsize=12, margin="0.18,0.10"];
edge  [color="#666666", arrowsize=0.7];

  openapi [style=invis];
  parser  [label="swagger-parser"];
  gen     [label="Glue code", fillcolor="#FFE66D",  // yellow highlight
        color="#C9A700"];

  jsongen     [label="Glue code + Koson", fillcolor="#FFE66D",  // yellow highlight
        color="#C9A700"];

  dtogen [label = "Glue code + KotlinPoet", fillcolor="#FFE66D",  // yellow highlight
        color="#C9A700"];
  tsgen [label= "openapi-generator"];
  adoc    [label="AsciiDoctor\ntoolset"];
  html    [label="", style=invis];
  jsonschema[label="", style=invis];
  kotlindto[label="", style=invis];
  tsdto[label="", style=invis];

  openapi -> parser [label="OpenAPI spec\ntransformations.yaml"];
  parser  -> gen [label="SwaggerParseResult"];
  gen     -> adoc   [label="transformations.adoc"];
  adoc    -> html [label="HTML+CSS"]

  parser  -> jsongen;
  parser  -> dtogen;
  parser  -> tsgen;

  jsongen -> jsonschema[label="JSONSchema"];
  dtogen  -> kotlindto[label="Kotlin DTO"];
  tsgen   -> tsdto[label="Typescript DTO"];

  {rank = same;
    html;
    jsonschema;
    kotlindto;
    tsdto;
  }
}
----

== Why Asciidoctor? Why not reStructuredText or Markdown?

[%step]
* *Richer semantics* out of the box: notes, callouts, quotes, and more
* *Powerful tables*: merged cells, advanced layouts impossible elsewhere
* *Attributes and conditional content*: +
(`:product:`, `:version:`, `ifdef::[]`, `ifeval::[]`) +
make documentation a configurable build artefact
* *Countless diagram-as-code integrations*: you can keep rich, colorful illustrations in plain text (Graphviz, PlantUML, Mermaid, Gnuplot, JSyntrax etc.)
* *Truly cross-platform*: Ruby developer? Javascript developer? JVM developer? -- there's native tooling for you!
* My favorite feature: `include::...[]`

== Code snippets with syntax highlighting


[source,asciidoc]
-----
[source,java]
----
include::../java/org/example/GCD.java[tag=javagcd]
----
-----


[.fragment]
[source,java]
----
include::../java/org/example/GCD.java[tag=javagcd]
----


== Code snippets with syntax highlighting

[source,asciidoc]
-----
[source,ruby]
----
include::../resources/gcd.rb[]
----
-----

[.fragment]
[source,ruby]
----
include::../resources/gcd.rb[]
----

== Code snippets with syntax highlighting

[source,asciidoc]
-----
[source,lua]
----
include::../resources/gcd.lua[]
----
-----


[.fragment]
[source,lua]
----
include::../resources/gcd.lua[]
----


== Code snippets with syntax highlighting

[source,asciidoc]
-----
[source,prolog]
----
include::../resources/gcd.pl[]
----
-----


[.fragment]
[source,prolog]
----
include::../resources/gcd.pl[]
----


== GraphViz


[cols=".^50a,<.^50a"]
|===
|
[source,asciidoc]
-----
[graphviz]
--
digraph G{
  graph [ dpi = 180 ];
  node[shape=box];
  A->B->C;
  B->D->A;
  C->A;
}
--
-----

|

[.fragment]
[graphviz]
--
digraph G{
graph [ dpi = 180 ];
node[shape=box];
A->B->C;
B->D->A;
C->A;
}
--
|===

== PlantUML

[cols="50a,50a"]
|===
|
[source,asciidoc]
-----
[plantuml, deadlock, png]
----
@startuml
skinparam dpi 180
hide footbox
participant X
participant Y
participant LockA
participant LockB
X -> LockA: lock()
activate LockA
LockA --> X:
Y -> LockB: lock()
activate LockB
LockB --> Y
X -> LockB: lock()
note right
  Deadlock!
end note
Y -> LockA: lock()
@enduml
----
-----
|
[.fragment]
[plantuml, deadlock, png]
----
@startuml
skinparam dpi 180
hide footbox

participant X
participant Y
participant LockA
participant LockB

X -> LockA: lock()
activate LockA
LockA --> X:

Y -> LockB: lock()
activate LockB
LockB --> Y

X -> LockB: lock()
note right
  Deadlock!
end note

Y -> LockA: lock()

@enduml
----
|===

== JSyntrax

[cols="50a,50a"]
|===
|
[source,asciidoc]
-----
[syntrax, format="png"]
----
indentstack(10,
  line(opt('-'), choice('0',
      line('1-9', loop(None, '0-9'))),
    opt('.', loop('0-9', None))),
  line(opt(choice('e', 'E'),
      choice(None, '+', '-'),
    loop('0-9', None)))
)
----

-----
|
[.fragment]
[syntrax, format="png"]
----
indentstack(10,
  line(opt('-'), choice('0', line('1-9', loop(None, '0-9'))),
    opt('.', loop('0-9', None))),
  line(opt(choice('e', 'E'), choice(None, '+', '-'),
    loop('0-9', None)))
)
----
|===


== Gnuplot

[cols="50a,50a"]
|===
|
[source,asciidoc]
-----
[gnuplot, gaussian, svg]
----
set title "Gaussian: e^{-x^2}"
set xlabel "x"
set ylabel "y"
set grid

f(x) = exp(-x**2)

set samples 400
set xrange [-4:4]
set yrange [0:1.05]

plot f(x) title "exp(-x^2)" with lines lw 2
----

-----
|

[.fragment]
[gnuplot, gaussian, svg]
----
set title "Gaussian: e^{-x^2}"
set xlabel "x"
set ylabel "y"
set grid

f(x) = exp(-x**2)

set samples 400
set xrange [-4:4]
set yrange [0:1.05]

plot f(x) title "exp(-x^2)" with lines lw 2
----
|===

== LaTeX-compatible formulae

[source,asciidoc]
----
[stem]
++++
\Huge
\int^{\infty}_{-\infty} e^{-x^{2}} dx = \sqrt{\pi}
++++
----

[.fragment]
[stem]
++++
\Huge
\int^{\infty}_{-\infty} e^{-x^{2}} dx  = \sqrt{\pi}
++++


== `include::` directive -- my favourite feature of Asciidoctor

[source,asciidoc]
-----
[source,java]
----
\include::../java/org/example/WordCounter.java[]
----
-----

[source,java]
----
include::../java/org/example/WordCounter.java[]
----

== When we need to include only the specific snippet

[quote]
____
This Java Streams API pipeline converts a `Stream<String>` of text lines into a `Map<String, Long>` mapping each lowercased word to the number of times it occurs in the input.
____

[source,asciidoc]
----
\include::../java/org/example/WordCounter.java[tag=pipeline]
----

[source,java]
----
include::../java/org/example/WordCounter.java[tag=pipeline]
----

[.fragment]
How do we make sure this claim is accurate? We need a test!

== The test that verifies the pipeline...

[source,asciidoc]
\include::../../test/java/org/example/WordCounterTest.java[]

[source,java]
----
include::../../test/java/org/example/WordCounterTest.java[]
----

== The test that verifies the pipeline...

[source,asciidoc]
\include::../../test/java/org/example/WordCounterTest.java[tag=test]

[source,java]
----
include::../../test/java/org/example/WordCounterTest.java[tag=test]
----

== How to make your Asciidoctor code snippets testable

* Keep documentation and tested example code in the same repository
* Use `include::[...]` with `tag=` to pull in only the relevant fragments
* Build the docs and run the example-code tests in the same CI pipeline.
* If the example breaks → the test breaks → CI fails.


== Why Antora?

* Versioned docs are a first-class concept

image::versions.png[]

[source,yaml]
----
content:
  sources:
  - url: ./testing-suite
    start_path: docs
    branches: [release-v1.138.0, release-v1.137.0, release-v1.136.0]
----


== Why Antora?

* Opinionated layout for modules, assets, examples, etc
* + coordinate-based xrefs (component/version/module/page)

A typical module layout:

[source,text]
----
user_guide
├───assets
│   └───images
├───examples
│   └───sql
├───pages
└───partials
----

[source,asciidoc]
----
// Antora style references
\include::user_guide:example$data_insertion.sql[tag=snippet]
image::user_guide:yamlview.png[]
xref:user_guide:020_getting_started/datasources.adoc[Data sources]
----

== Why Antora?

It's really fast!

image::fast.png[width=90%]

== When possibly NOT Antora?

* Too opinionated, too Git-centric, too many nested folders -- not for novices
* Moving sections around is not an easy task
* When a large part of your documentation is descriptive narrative, not necessarily tightly coupled with versioning and releases

== Conclusions

* Keep documentation close to your source of truth
* Generate documents in plain adoc -- let Asciidoctor toolset do the rest
* Use the Asciidoctor's `include::` magic in order to include testable examples
* Docs + Code = Love!

== Thanks for listening!

Slides-as-code: https://github.com/inponomarev/dsl-antora-talk

icon:envelope[size=lg] ivan@synthesized.io

icon:twitter[size=lg] @inponomarev